private:
    int *array;
    int amountOfBitFields; // число элементов массива
    int start; // начало
    int end; // конец

private:
    // объединяет множества при этом first - множество, которое начнется раньше second
    void combiner(const BitFields_set& first, BitFields_set& second);
        // ищем в методе whereZero для обоих множеств, где у них находится 0 или должен находиться
        (если возвращается число > amountOfArrayElements то все множество до 0, если возвращается число < 0 то все множество больше нуля)

        // идем фором по созданному множеству, куда будем добавлять элементы
        (рассматриваем 3 случая (оба множества < 0, оба множества > 0 и одно множество до нуля, второе после нуля))
        // идем по first и добавляем элементы в С, если не началось еще second
        // если второе множество началось - делаем |
        // если первое закончилось, то присваиваем только элементы second


    // поиск элемента массива, в котором находится число Х
    // поиск разряда числа в битовом поле - читаем число справа налево (в digit заносит)
    // возвращает -1, если число вне границ start end
    int searchBitField_and_Digit(int x, int& digit) const;
        // считаем, сколько элементов массива до нуля - beforeZero
        // если лежит в подмножестве >= 0 или только положительные числа
           (x+1) % 32 == 0 ? ((x+1) / 32) : ((x+1) / 32 + 1)
           digit = (x+1) % 32 - 1;
        // вычитаем из него неиспользованные биты(если есть) или же прибавляем beforeZero

        // если множество из отрицательных чисел или лежит в подмножестве < 0
           abs(x) % 32 == 0 ? beforeZero - ((abs(x)-1)/32) : beforeZero-(abs(x)/32);
           digit = abs(x) % 32 == 0 ? 0 : 32 - (abs(x) % 32);


    // возвращает номер битового поля, в минимальном бите которого 0
    // если вернулось число больше, чем элементов в множестве – отрицательные числа только
    // если число отрицательное - число целых полей до 0
    int whereZero();
        // если разные знаки - ноль есть - возвращаем номер элемента массива
        // если только отрицательные – amountOfBitFields + (abs(end) / 32)
        // если только положительные – -((start+1) / 32)


    void copy(BitFields_set& copy);
        // выделяет память
        // заполняет такими же значениями, что в copy
        // все приватные значения тоже переносит


    // какое десятичное число находится в элементе массива arrayElement и в разряде digit
    int whatsNumber(int arrayElement, int digit);


public:
    // конструктор по умолчанию (множество задаем и выделяем память)
    BitFields_set(int start, int end);

    // копирующий конструктор - отправляет в copy
    BitFields_set(const BitFields_set& B);
        // проверяет не равны ли В и this

    // UNION новое множество возвращает – отправка в UniMerge
    BitFields_set& UNION(const BitFields_set& B);
        // если В == this – возвращаем В
        // если !В и this – возвращаем this
        // если !this и В – возвращаем В
        // если !this и !В – пустое множество возвращаем
        // создаем С
        // выделяем память под С – берем минимум из минимума и максимум из максимума
        // если this.start <= B.start – C.combiner(this,B)
        // иначе – C.combiner(B, this)
        // возвращаем С


    // INTERSECTION пересечение множеств this и В (проверка на наличие множеств) – отправка в crosser
    BitFields_set& INTERSECTION(const BitFields_set& B);
        // если В == this – возвращаем В
        // если !this или !В или this.start > B.end или B.start > this.end – возвращаем пустое множество
        // создаем С
        // выделяем память под С – берем минимум из максимума и максимум из минимума
        // смотрим, какой start меньше (и в нем с помощью searchBitField_and_Digit ищем начало C, чтобы пропустить эти биты)
        // фором идем от 0 до конца С и делаем пересечение с каждым элементом массива
        // возвращаем С


    // DIFFERENCE разность множеств this и В
    BitFields_set& DIFFERENCE(const BitFields_set& B);
        // если В == this – возвращаем пустое множество

        // создаем С и через копирующий конструктор присваиваем ему this
        // если !this или !В или start > B.end или B.start > end – возвращаем С
        // с помощью searchBitField_and_Digit ищем, с какого элемента массива С начинается В (если start у В больше С)
            // или же с какого элемента массива В начинается С (если start у С больше В)
        // whileом до конца С или до конца B
            // делаем для каждого array[i] = array[i] & ~(array[i] & B.array[j]);
        // возвращаем С


    // слияние множеств А и В, результат в С. На непересекающихся множествах!!!!
    BitFields_set& merge(const BitFields_set& B);
        // если пересекаются – выбрасываем исключение
        // если this и !В – возвращаем this (аналогично наоборот)
        // если оба множества пустые – возвращаем пустое множество
        // создаем С
        // выделяем память под С – берем минимум из минимума и максимум из максимума
        // если this.start <= B.start – C.combiner(this,B)
        // иначе – C.combiner(B, this)
        // возвращаем С


    // true - х принадлежит А, false - не принадлежит
    bool member(int x);
        // если !this – возвращаем false
        // в методе searchBitField_and_Digit() находим разряд и номер элемента массива, в котором по идее должен быть х
        // возвращаем true если он там есть


    // вставить в множество значение
    void insert(int v);
        // с помощью searchBitField_and_Digit находим сразу разряд и номер элемента массива
        // если номер != -1 (то есть входит в промежуток)
            // создаем элемент, сдвигаем 1 на нужный разряд
            // делаем | с элементом array[num]


    // из множества А удаляется значение х, если оно там есть, иначе ничего не делаем
    void deleTe(int x);
        // если !this – return
        // получаем с помощью searchBitField_and_Digit номер элемента массива, где должен находиться х и его разряд
        // если != -1 (то есть входит в промежуток)
            // создаем элемент, сдвигаем 1 на нужный разряд и инвертируем
            // делаем & с элементом array[num]


    // ASSIGN присваивание А мн-ва В. В не меняется
    BitFields_set& operator= (BitFields_set B);
        // если В == this – возвращаем this
        // отправляем в деструктор this
        // отправляем в copy(B)
        // возвращаем this


    // минимальный элемент списка
    int min();
        // проверяем выделена ли память вообще под массив – если нет, то возвращаем минимум для int
        // фором идем по элементам массива и по отдельным битам
            // если бит 1 и элемент массива не равен 0
                // возвращаем значение из закрытого метода whatsNumber()
        // иначе возвращаем минимум для int


    // последний элемент списка
    int max();
        // проверяем выделена ли память вообще под массив – если нет, то возвращаем максимум для int
        // фором идем по элементам массива и по отдельным битам (по убыванию)
        // если бит 1 и элемент массива не равен 0
             // возвращаем значение из закрытого метода whatsNumber()
        // иначе возвращаем максимум для int


    //  EQUAL true, если множества A и B эквивалентны. false, если множества A и B  не эквивалентны.
    bool operator==(BitFields_set& B);
        // если В == this – возвращаем true
        // если !В или !this или не пересекаются вообще – возвращаем false
        // у массива, который начнется раньше запоминаем элемент массива, в котором бОльший start
        // идем фором от 0 до бОльшего end
            // проверяем элементы от 0 до whereStartB – чтобы они были равны 0
            // проверяем элементы от конца первого закончившегося до конца – чтобы они были равны 0
            // проверяем на равенство совпавший отрезок
        // возвращаем тру если все ок


    // возвращает то множество, в котором обнаружен объект х. Если не найден, то возвращаем пустое множество - NULLPTR (ни А, ни В).
    BitFields_set& find(BitFields_set& B, int x);
        // если !this и В – ищем только в В (и наоборот)
        // получаем с помощью searchBitField_and_Digit номер элемента массива, где должен находиться х и его разряд
        // если != -1 и при | понимаем, что там 1 – возвращаем this
        // то же самое проделываем с B
        // иначе пустое множество возвращаем


    // доп. метод - проверяет пересекаются множества или нет
    bool isIntersect(const BitFields_set& A, const BitFields_set& B);
        // если В == A – возвращаем true
        // если !A || !B – возвращаем false
        // с помощью searchBitField_and_Digit ищем, с какого элемента массива A начинается В (если start у В больше A)
             // или же с какого элемента массива В начинается A (если start у A больше В)
        // whileом идем до конца A или до конца B
            // если & чисел не равно 0 – возвращаем true
        // возвращаем false